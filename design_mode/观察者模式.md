### 观察者模式

#### 1. 介绍

指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，

观察者模式是对象行为型模式。

#### 2.解决思想

- 使用面向对象技术，可以将这种依赖关系弱化。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

#### 3.观察者模式的结构

观察者模式的主要角色如下。

- 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
- 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
- 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
- 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。

#### 4.观察者模式的优点和缺点

其主要优点如下。

1. 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。
2. 目标与观察者之间建立了一套触发机制。


它的主要缺点如下。

1. 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
2. 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

#### 5.观察者模式的应用场景

1. 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。
2. 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
3. 实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。
4. 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。

#### 6.代码实现

```c#
namespace ObserverPattern
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("实例化目标");
            Subject subject = new ConcreteSubject();
            Console.WriteLine("实例化两个观察者：Observer1、Observer2");
            Observer obs1 = new ConcreteObserver1();
            Observer obs2 = new ConcreteObserver2();
            subject.add(obs1);
            subject.add(obs2);
            subject.Radio();

            Console.ReadKey();
        }
    }
    //抽象目标
      public abstract class Subject
      {
        protected List<Observer> observers = new List<Observer>();
        //增加观察者方法
        public void add(Observer observer)
        {
            observers.Add(observer);
        }
        //删除观察者方法
        public void remove(Observer observer)
        {
            observers.Remove(observer);
        }
        public abstract void Radio(); //通知观察者方法
      }
      //具体目标
      public class ConcreteSubject : Subject
      {
        public override void Radio()
        {
           Console.WriteLine("通知观察者目标发生改变...");
          
           foreach (Object obs in observers)
           {
              ((Observer)obs).response();
           }
        }

        
    }
     //抽象观察者
     public  interface Observer
     {
         void response(); //反应
     }
     //具体观察者1
     public class ConcreteObserver1 : Observer
     {         
         public void response()
         {           
            Console.WriteLine("观察者1已接受到消息，作出反应！");
         }
     }
     //具体观察者1
     public class ConcreteObserver2 : Observer
     {
         public void response()
         {
            Console.WriteLine("观察者2已接受到消息，作出反应！");
         }
     }
}
```

##### 运行结果

![](C:\Users\Lenovo\Desktop\mg\观察者模式.PNG)



